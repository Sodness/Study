<stdio.h>ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
printf(), scanf_s() 등등

<conio.h>ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
Visual Studio에서만 사용가능

getch 함수는 비표준 함수이기 때문에 Visual Studio 2015에서 사용하면 컴파일 에러가 발생합니다. 
따라서 #define _CRT_NONSTDC_NO_WARNINGS를 지정하여 컴파일 에러가 발생하지 않도록 만듭니다. 
만약 매크로를 지정하지 않으려면 getch 대신 _getch 함수를 사용하면 됩니다.

getch() - 버퍼에 있는 값을 꺼내오는 역할을 한다.

kbhit() [KeyBoardHit], 아스키코드 - 버퍼에 값이 있으면 1을 없으면 0을 리턴한다.

여기서 clearscr()도 씀

http://individuality.tistory.com/55
https://dojang.io/mod/page/view.php?id=761

<time.h>ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
시간 관련...

<windows.h>ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
콘솔창을 이용하여 무엇인가를 하고 싶을 때 사용하는 총괄 헤더

system("cls")

Sleep() - 1000 == 1초

<32행>ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
internal - 내부의, 체내의

<34~36행>ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
왜 int형으로 선언했는지 아직모름...

<46~54행>ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
함수의 프로토타입 선언 중간에 왜 엔터가 있는지 아직모름... 함수 기능의 구분이라고 추측.

<83행 DWORD>ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
typedef unsigned long       DWORD;
typedef int                 BOOL;
typedef unsigned char       BYTE;
typedef unsigned short      WORD;	줄여서 쓰는 것 인듯...

<88행 GetTickCount()>ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
주로 두 사건 사이의 경과 시간을 측정하기 위한 용도로 사용하며 
또는 간단한 애니메이션, 커스텀 커서의 깜박임 주기 조정 등의 용도로도 사용할 수 있다. 

<90~100행>ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
각각 무슨 일을 하는지는 해석이 가능하지만 이 함수를 실행할 때 초래하는 기능, 결과의 예측이 힘듬...
GetTickCount()의 조사결과를 토대로 (애니메이션, 커스텀 커서의 깜박임 주기 조정 등의 용도)로 쓸 것이라 추측함...

+GetTickCount() : OS(컴퓨터 운영체재)부팅할 때부터 지나간 시간을 msec 단위로 돌려주는 함수이다.
+GetTickCount() 함수를 이용하여 특정 루틴의 소요시간을 알아내는 방법에 대해서 알아보겠습니다.
( 예를 들어 A()라는 함수의 소요시간을 알고 싶다면 다음과 같이 하면 됩니다. )

int start = 0, end = 0, time_data = 0;

start = GetTickCount(); 

A(); 

end = GetTickCount();

//이렇게 하면 time_data에 소요 시간이 들어가게 되고, 단위는 밀리 세컨드가 된다.
//time_data 가 100 이 나왔다면, 100 밀리 세컨드 즉  0.1초가 된다. (1000 == 1초)
time_data = end - start;

+timeGetTime() 함수
윈도우(운영체제)가 시작되어서 지금까지 흐른 시간을 1/1000 초 (milliseconds) 단위로 DWORD형을 리턴하는 함수다.

=> 같은 GetTickCount() 함수가 아니지만 DWORD형을 리턴한다는 걸 볼때 GetTickCount() 함수도 같을 거라고 예상할 수 있다.

<107~108행>ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
구조체 snake_internal 에 선언된 변수 org_len, cur_len 을 각각 41, 21로 초기화 하고 있음...
왜 특정한 숫자인 41, 21로 측정하는지는 아직 모름...
41은 snake 구조체 변수 body 배열의 최대 값임을 고려해서 한계치를 정했다고 조심스럽게 추론해 봄..
21은 아직 어떠한 추론도 하기 힘들다고 판단함...

<111~115행>ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
구조체 snake 에서 선언한 변수 body_x 에는 i가 0일때 42부터 i가 40일때 2까지 숫자를 줄여가며 각각 대입중...
반면 body_y 는 5로 고정된 값이 대입중이다.
110행에 스네이크 초기위치 설정 및 출력 이라고 써 있으므로 위쪽 for문은 설정 아래쪽 for문은 출력 이라는 추론이 가능...

<116~120행>ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
씁.... 흠.. currentXY() 추론대로라면 이부분이 출력이고 출력이라고 거의 확신하고 있다.
왜냐하면 printf("%c", snake[i]); 가 있기 때문이다. 

인터넷 검색을 해본 결과 snake 게임은 열매를 먹을 때 마다 
몸 길이가 길어진다. 위쪽에 선언된 snake[41] = ""를 보면 문자열이 29이다. 흠... 
그렇다면 열매를 12번 먹으면 게임 클리어인 것인가.... 잠깐 얘기다 다른데로 새버렸는데 for 문의 조건은 20까지 출력이다. 
그렇다면 위에서 29개나 선언한 이유랑은 관련이 없는 것인가? 여하튼 몸길이 20짜리 뱀을 출력한다.

그렇다면! 여기서 119행으로도 화면에 출력은 충분히 가능하다. 여기서 currentXY()는 어떤 기능을 하는지 생각해보자.
매개변수를 관찰하면 뒤쪽이 5인것으로 미루어 보아 매개변수는 각각 위 for문에서 대입한 x, y 와 비슷한 경향을 띈다.

더 이상의 추론은 힘들거라고 예상되므로 조금 직관적으로도 생각해보겠다.
이미 119행에서 출력이 되고 있는데도 118행을 써 놨다... 그렇다면 118행 currentXY()는 현재 뱀의 x, y 위치를 받아오고
그 위치에 뱀을 출력 한다고 조심스럽게 예상해 본다.

<112~123행>ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
흠... dx = 1, dy = 0 이라... 제일 처음 든 생각은 버퍼 관련이었다.

kbhit() [KeyBoardHit], 아스키코드 - 버퍼에 값이 있으면 1을 없으면 0을 리턴한다. -> 이런 내용을 조사한 적이 있어서 였다.
허나 1이면 무엇을 0이면 이것을 이 아니라 버퍼에 값이 있으면 1 없으면 0 이므로 순서가 반대여서 아니라고 판단...

그 다음으로 든 생각은 true, false 인 건가?

잠깐 착각한게 배열 int body_x[41] 말고도 int body_dx 가 있었다. 후에 어쩌면 true false 일지도 모르지만
지금은 우선 왜 어떠한 목적으로 각각 1과 0을 대입한지는 모르겠지만 구조체 snake의 변수 dx, dy는 초기화 됐다.

<133~135행>ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
스크린의 초기화.....라..

<138행>ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
잠깐만 clearscr() 이게 스크린 초기화 아녔어? 왜 똑같은 짓을 두번하고 있어?

clearscr() 함수는 화면을 지우는 함수이고
system("sls"); 와 비슷한 기능을 한다.

system("sls"); 를 쓰려면 conio.h 와 더불어 stdlib.h 를 같이 써줘야 한다.

그러고보니 NULL로 하고 왜 화면을 또 지우는 지는 모르겠네

https://www.hooni.net/xe/study/1237

<141~143행>ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
첫째줄... 어~~~~ D드라이브 game_map 폴더에 있는 snake 받아오기 즉 내가 이해하기론 strcpy(filename, snake);

둘째둘... 허~~~~ 이게 주소
http://norux.me/24 거의 정리가 완벽에 가까움 간단히 하자면
atoi(), itoa() 함수는 헤더 stdlib.h에 선언되어 있다.

atoi() 문자열을 정수형으로 변환
itoa() 정수형을 문자열으로 변환 인데!! 여기서 잠깐 

itoa는 마이크로소프트 비주얼스튜디오에서만 정의해놓은 함수입니다. 
따라서 우분투 등 다른 플랫폼에서 개발하시는 분은 사용하실 수가 없었을 겁니다. 
그래서 전 itoa 함수 대신에 sprintf를 사용하는 것을 권장드립니다! (글 서두에 연결된 링크를 참조하시길 바랍니다.) 라고 함...

결국 itoa(문자열로 변환할 정수, 변환한 값을 저장할 변수, 10진수면 10, 2진수면 2)

두번째 줄을 거치자 filename은 snake(no) 여기서 no는 매개변수로 받은 정수형 임

세번째 줄 흐~~~~ 을 거치자 filename은 snake(no).txt가 됐따!!!

<145~152행>ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
어허.... 이거 이상하구만 위에서 문자형 배열 filename[27] 이 snake(no).txt 가 됐다지만 이걸 fopen() 한다니
이게 말이 되오?? 그것도 읽는 용도로? 안에 쓴거 없었던거 같은데?

호오... 그래서 이제 fp == NULL 이면 이라는 조건이 있나? 조건이라면 이게 NULL 이 아닐 때도 있다는 건데 그 상황은
어떻게 해야 나오는 걸까? 일단 if문 안을 살펴보면 currentXY(30, 12) 현재 위치를 x = 30, y = 12로 지정하는 것으로 추정함
다음줄은 뭐 출력이고... getchar() 이게 그 받는 문자 출력에다가 엔터까지 받는 성실한 놈이고 exit(1) 무조건 나감...

<154~157행>ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
위에서 fp == NULL 일때 했으니까 아래에서는 NULL이 아닐 때의 경우구만

screen[][] 2차로 선언해 놓고 치사하게 screen[] 이렇게 받고 있네 24까지 인거 보면 앞쪽 배열인듯
중간에 80 뭐야 이거 원래 fgets() 함수가 매개변수가 3개였나? 아... 보니까 예를 들어 i = 0 일때 80까지 읽는 "r" 용도로 
fopen() 한 fp 를 screen[0][0~79] 에 저장한다 이런 의미인가 보다.

마지막으로 깔쌈하게 fclose() 해주고 끝

<160행 void clearscr()>ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
함수이름: clearscr (clearscreen) 이겠지 -> 화면을 깨끗이한다. 화면의 초기화 인듯

165-166행 : 40행에서 char screen[24][80]; 선언해 놓음
168-169행 : currentXY()로 좌표 찍고 printf() 로 공백 출력 => 화면 전체에 공백 출력

<176행 apple_item(int ea)>ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
181행     : 42행 int apple;
            43행 char apple_data[6] = {2, 3, 3, 4, 5, 5}; -> 왜 char로 했을까?

+ rand(), srand()
C   : stdlib.h
C++ : cstdlib

rand()  : 난수 생성 함수 0~RAND_MAX까지의 정수 1개를 리턴한다.
srand() : srand()로 시드값을 설정해 줄 때마다 rand()의 리턴값이 변한다.

srand()의 인수는 unsigned int 타입이다.

보통 srand((unsgned int)time(NULL))로 1970년 1월 1일 이후의 경과된 시간을 초 단위로 변환한 값을 넣는다.
=> 실시간으로 rand()의 시드값이 변한다.

rand() % M		0 ~ (M-1)   까지의 수가 생성됨
rand() % M + N 		N + (M+N-1) 까지의 수가 생성됨

rand() % 100		0 ~ 99  (0 ~ (100-1))   생성
rand() % 100 + 1	1 ~ 100 (1 ~ (100+1-1)) 생성

D\자료\컴퓨터프로그래밍\스네이크

182-192행 
1. 정해둔 사과의 개수 만큼 실행한다.
2. 일단 시드값에 변수를 넣고 화면에 맞게 80, 24로 나눠서 x, y에 대입
3. x, y 좌표에 따른 공간이 #(벽), *(머리), +(몸통), @(사과) 가 아닐 때까지 반복
4. 빈 공간에 사과를 둔다.

194-204행
1. 책을 읽듯이 내려감
2. 공간 좌표에 #(벽) 또는 @(사과)가 존재한다면 출력후 이를 반복함

<207행 select_direction(void)>ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
211행 : prev_x, prev_y -> previous(이전의)?

215행 : kbhit(keyboardhit) 주로 게임을 만들때 자주 사용 된다. 이 함수를 사용하기 위해선 conio.h 헤더를 추가해야 한다.
        보통 프로그램은 입력값이 있을 때까지 아무것도 하지 않고 기다리는데 게임은 입력이 없어도 게임은 지속되야 하기에
        키보드에 입력이 있었을 때 "1(true)" 을 반환하고 입력이 없을 땐 "0(false)" 를 반환한다.
        이렇게 할 경우 게임은 계속 움직이며 지속이 가능하고 방향키, 단축키를 눌렀을 때 그에 따른 반응이 가능해 진다.

213-241행
1. 게임을 특성을 고려할 때 방향키를 누를 때 마다 한칸씩 가는게 아니기 때문에 이를 고려해서 코딩을 한듯 하다.
2. 제일 첫 줄에 '스네이크의 방향 (좌, 우, 상, 하) 선택' 이라고 써있는 걸 볼 때 뒤에 어떤 기능을 하는 코딩이 올지 알 수 있다.
3. 키보드로부터 입력을 받는다.
4. 왼쪽이면 "dx" 를 -1 방향으로 "dy" 는 0으로 유지한다. "-, +, 0(유지)" 를 감안 할 때
   수학에서 그래프를 그릴 때 쓰이는방법과 유사하다.
5. 오른쪽, 위, 아래도 같은 방법으로 이어간다.
6. 엔터를 입력 받았을 땐 "Program aborted(프로그램을 종료합니다.)" 를 출력 후 exit(0) 종료한다.

243-261행
아무리 봐도 잘 모르겠다. 특히 246-250행
244-245행은 현재 뱀의 길이를 그대로 옮기는 것 같고
251-261행은 입력값에 따라서 "*(머리)" 를 돌리는 것 같은데

246-281행
1. 길이를 옮기는게 아니라 좌표 찍는 거였어? 또 왜 공백으로 출력하고 자빠졌어?
2. 정해진 화면안에 뱀의 머리(?)가 존재 한다면
3. 현재 위치를 받아서 머리를 출력한다.
4. 현재의 길이가 될때 까지 현재 위치를 받아서 "+(몸통)" 을 출력한다.

<284행 int decide(int no)>ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[290-296행]
screen[snake_attr.body_y[0] -1][snake_attr.body_x[0]-1] == '@' -> 이거 뭐야 뭔 짓하는 거야
아... 혹시 머리앞에 사과가 있나 그걸 보는거 같은데 '그래서' 먹으면 몸길이 늘리고 사과 개수 줄이고
더 이상 먹을 사과가 없으면 종료

여기서 snake_attr.body_x[0], snake_attr.body_y[0] 을 머리로 보는 거 같네

[298-316행]
머리 바로 뒤 '+' 부터 현재 길이의 끝 '+'까지 

snake_attr.body_x[0]==snake_attr.body_x[i] &&
snake_attr.body_y[0]==snake_attr.body_y[i]       => 머리가 몸통과 겹치면

생명을 깎는다. 만약 생명이 남아있다면 스테이지에 맞춰 다시 맵을 부르고 게임을 새로 구동하고 사과를 둔다.
뭐 생명이 안 남아있다면 게임 오버지 뭐

[318-331행]
만약 머리부분이 화면의 테두리에 닫았다. 또는 장애물에 부딪쳤다면(머리 앞에 '#(장애물)'이 있다면)
생명을 깎는다. 만일 생명이 남아있다면 스테이지에 맞게 맵을 불러온다. 게임을 새로 시작한다. 사과를 둔다.

[333-343행]
만약 생명이 더 이상 없으면 
좌표 30, 12에 게임오버를 출력한다.
좌표 32, 15에 다시 할지를 묻는다.
다시 할지 입력받고 그에 따라서 처리한다. 나라면 if(retry == 'Y') main(); 으로 할텐데 억지로 껴넣은 느낌이 나네

+toupper()+
헤더파일 	: ctype.h
형태	 	: int toupper(int ch)
인수		: int c (변환할 문자)
반환		: c가 소문자일 때만 대문자로 변환하여 반환하고, 소문자가 아니라면 그대로 반환

<348행 void currentXY(int x, int y)>ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
+COORD+
헤더파일	: windows.h

typedef struct _COORD {

    short X;

    short Y;

} COORD;

좌표값을 저장하는 구조체

여기서는 void currentXY(int x, int y)로 사용 하고 있는데 
많은사람들이 약속 하고 쓰는 이름은 void gotoxy(int x, int y) 이다.

+커서 이동 함수+
void gotoxy(int x, int y)
{
     COORD Location;
     Location.X=x;
     Location.Y=y;
     SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), Location);
}

화면상 원하는 위치에 출력하기 위해서 만드는 함수의 기본적인 틀이다.
헤더파일	: windows.h(정확히는 이 헤더 안에 있는 WinCon.h)

이 함수의 핵심은 
SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), Location); 
이 부분이다.

말이 어려워서 뭐라는지는 잘 모르겠는데(실제 핸들, 파라미터, 표준콜솔출력, OS내부) 뭐라뭐라 하는데
다행히 쉽에 정리해준 말이있다.

- 정리해보면, SetConsoleCursorPosition 함수에, 콘솔의 출력 핸들을 주고, 위치를 정해주면 커서가 이동하는 것이다.

=> 더 쉽게 이해 하자면 마우스 커서로 0 바로 뒤를 클릭후 @을 출력해봐라

                    1               3                    0@                      2                         

이런 식인 것이다. 

====================================================================================================================

이건 그냥 참고인데 콘솔에서 가로, 세로의 최대 크기는 80, 25칸 이라더라. (0, 0) 부터 (79, 24) 까지
? 거꾸로 아니냐? 가로, 세로 25, 80 잘 못쓴건가?

https://m.blog.naver.com/PostView.nhn?blogId=sharonichoya&logNo=220873844942&proxyReferer=http%3A%2F%2Fwww.google.co.kr%2Furl%3Fsa%3Dt%26rct%3Dj%26q%3D%26esrc%3Ds%26source%3Dweb%26cd%3D1%26ved%3D0ahUKEwixlvC-reHYAhXKTbwKHfz-Bz4QFggmMAA%26url%3Dhttp%253A%252F%252Fm.blog.naver.com%252Fsharonichoya%252F220873844942%26usg%3DAOvVaw0gaIsdtmAdSnyOMS9BYz_H

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
_s 는 잠재적인 문제점들(보안, 메모리 등)에 대한 경고이다.

이 메시지를 보지 않고 무시하길 원한다면 코드의 시작에 다음과 같이 매크로를 정의하면 된다.
#define _CRT_SECURE_NO_WARNINGS
또는 #pragma warning(disable:4996)
또는 "프로젝트 속성" → "구성 속성" → "C/C++" → "전처리기" 탭에서 "전처리기 정의" 항목에 "_CRT_SECURE_NO_WARNINGS"를 추가해 주어도 된다.

http://hh4131.tistory.com/22

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
방향키의 아스키코드를 구하는 법

스네이크 폴더에 "방향키의 아스키 값 받기" 있음
http://blog.naver.com/PostView.nhn?blogId=8527l&logNo=30177393048&parentCategoryNo=&categoryNo=24&viewDate=&isShowPopularPosts=false&from=postView
http://blog.naver.com/PostView.nhn?blogId=sharonichoya&logNo=220875372940&parentCategoryNo=&categoryNo=22&viewDate=&isShowPopularPosts=true&from=search

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
exit(0) 과 exit(1)의 차이점

exit(0) : 정상적인 종료
exit(1) : 에러가 발생 했을 경우의 종료 (주로 if문에 넣어 놓음)

라고 약속되 있음 exit(1)으로 하면 뭔가 나올지는 해봐야 함 (스네이크 폴더에 있고 해봤음 일단 근데 뭐 차이가 없어 ㅅㅂ)


